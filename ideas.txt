


Current Ideas
===========================================================
Every construct begins with the name of the construct.
This is to prevent ambiguity.  Say you had the construct
called "not" and the construct called "inc", where
"not" expects an arguments after the construct, and "inc"
expects the argument before:

not <arg>
<arg> inc

If you saw

not 2 inc

You wouldn't know if it was (not 2) inc or not (2 inc).

You could say that it always evaulates left to right, or
right to left, but I'm not sure the added complexity of this
is worth the benifit.  So for now, all constructs must
begin with the name of the constructs.  That's not to say
that a construct has to be alpha-numberic characters. Maybe
symbols like "+" or "/" could be constructs themselves, but
for now, but syntax has no way to parse represent these special characters.

By assuming that all constructs start with the construct name, you can
easily determine the order of operations (todo: come up with examples)

#### The Dot Operattor






The semi-colon
--------------------------------
Some constructs require a semi-colon to terminate, however some do not.
The ones that do not require a semi-colon, will return a value. i.e.

  set x 3

This returns the symbol x, unless you terminate it with a semicolon

  set x 3

Construct Patterns
--------------------------------

A construct consumes objects based on a pattern definition.
The pattern definition determines how construct objects are consumed
and also defines the interface to the construct implementation.




// defcon import (names string ...) requiresBreak=true;
// The 'import' construct takes one or more strings, followed by a semi-colon.
// It also returns nothing.
import-pattern ::= string* break

// the 'let' construct: grammar definition
let-pattern ::= symbol object break?

// the 'message' construct grammar definition
message-pattern ::= anything* break

// the 'try' construct grammar definition
try-pattern :: block ('catch' block)? ('finally' block)?

// the 'return' construct
return-patter :: value? break



defcon defcon (pattern list null) requiresBreak=true;
// A defcon with no code block implementation requires a terminating semi-colon break.
// If no params list is specified, the values is null

defcon defcon (pattern list null, implementation constructBlock) noBreak=true;
// This version includes an implementation and must not have a terminating semi-colon break.
// If no params list is specified, the values is null

defcon exec (code constructBlock);

//defcon deftype












--------------------------------------------------
Pattern Consumers:
Consume objects if they match the pattern.


The '+' construct
  number '+' number
  pointer '+' number
  pointer '+' pointer

The '/' construct
  number '/' number


8 + 4 / 2
8 / 4 + 2

The '++' construct
  number '++'
  pointer '++'
  



The 'message' construct
  'message' anything* ';'

