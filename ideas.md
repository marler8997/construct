
Current Ideas
===========================================================

### Construct and Operator Precedence

One model I could use to represent operator precedence is a railroad diagram.
In these diagrams, an operator's precendece is higher the further to the right
it is located.

The rails will be generated by special constructs than define the relative
precendence between operators. Each time a rail is defined, the operators are
positioned in the railroad so the lower precedence operator is on the
left and the higher precedence is on the right.

Using this model, it's possible that two operators cannot be compared.
In order to be comparable, two operators must be connected
by a rail that doesn't switch directions (I think).

A can be compared to B:
```
( A )---(...)           (...)---( B )
           \             /
            \---(...)---/
```

A cannot be compared to B:
```
( A )---(...)   ( B )---(...)
           \             /
            \---(...)---/
```

These rails are created with a sequence of "higherThan" and "lowerThan" constructs:
```
precedenceGroup summation + -;
precedenceGroup multipler * /;
precedence multipler higherThan summation;

// ERRORS:
precedence * higherThan summation; // ERROR: * is already part of a precedenceGroup 'multipler'
precedence multipler higherThan +; // ERROR: + is already part of a precedenceGroup 'summation'

precedence . higherThan multipler;
precedence construct higherThan .;

// ( + - )---( * / )---( . )---(construct)
```
Say the operator modulus `%` is higher than summation,
but not int the same group as `*` and `/`:
```
precedence % higherThan summation;
//
// ( + - )---( * / )---( . )---(construct)
//      \
//       \---( % )
//
```
Now if you saw `a.b%c`, you will get an error because
the `%` operator is not comparable with the `.` operator.

But now let's put it in the same tree:
```
precedence % lowerThan .;
//
// ( + - )---( * / )---( . )---(construct)
//      \               /
//       \---( % )-----/
//
```
Now `%` can be compared to everything but `*` and `/`.
The other way of specifying the precedence of operator `%` would
be to add it to an existing precedence group like this:
```
addToPrecedenceGroup multipler %;
// ( + - )---( * / % )---( . )---(construct)
```

Construct Hooks and Contracts
--------------------------------
Constructs can not only implement a call body, they can also implement other types of code.
For example, they could implement an "argumentConstraints" block, or a "beforeCall" block,
or an "afterCall" block.  For example:
```
defcon / (top number, bottom number)
argumentContraints
{
  bottom != 0;
}
{
  return top / bottom;
}
```
The argument constraints are used to allow the caller to verify their own arguments. If the same
construct is called multiple times, or multiple constructs are called with simlar constraints,
this allows the caller to only verify the arguments once.  The caller can also decide what to
do when the argumentConstraints fail, maybe they assert, throw an exception, or don't call
the construct at all.

I'd also like to support some type of in and out constructs. Statements that tell you something
about the construct before and after the call.  This will give the compiler more information
about what the function does and allows for more optimization.

The 'raw' pattern node modifier
--------------------------------
> Note: another good name for this modifier could be 'source'

When a pattern node is marked as 'raw', it means that the node will be matched against
the unprocssed source objects. For example:
```
defcon matchNormalNumber(value number) ...
defcon matchRawNumber(value raw number) ...

matchNormalNumber 42 // good
matchRawNumber 42    // good

let x 197;

matchNormalNumber x  // good
matchRawNumber x     // error: no pattern matches 'x'
```
The last example fails because the number must be a "raw" source object.  For a normal pattern
node, when the symbol x is being matched, it is first looked up in the symbol table, if it has
an entry, the entry will be passed to the construct, not the symbol "x" itself.  For a "raw"
pattern node, the source object itself is passed to the construct.

Some of the basic primitive constructs use raw pattern nodes, i.e.
```
defcon let (name raw symbol, ...)
defcon defcon (name raw symbol, ...)
```

> Note: for now I'm NOT going to support using the 'raw' modifier on the operator pattern node.
```
defcon someOp (this raw) // INVALID, raw not supported on the 'this' pattern node
```

##### The 'macro' construct

In the case where you would like to use processed construct objects where a raw pattern node
is matched, you can simulate raw source objects using the 'macro' construct. It is a special construct
that causes the pattern matcher to enter regular processing mode even though it's matching
a raw construct.  For example, these three examples all do the same thing, they all assign
the symbol x to the number 42.
```
let x 42;

// NOTE: the symbolRef construct taks a raw symbol and returns it
let varName symbol x; // set the symbol 'varName' to the symbol 'x'
let macro varName 42;

let macro symbol x 42; // do the same thing in one line
```

### Ambiguity

It may be a good idea to setup some kind of matching precedence, maybe raw pattern node matching
will have higher priority than normal pattern nodes?  Here's an example of ambiguity:
```
defcon matchSomething(rawSymbol raw symbol) ...
defcon matchSomething(value number) ...

let x 3;

matchSomething x // matches both
```

I could setup a precedence, or just throw an error.  I'll probably initially just throw an
error when multiple patterns are matched.


Implicit Cast Operators
--------------------------------
Provide a way to write implicit cast operators.

The semi-colon
--------------------------------
Some constructs require a semi-colon to terminate, however some do not.
The ones that do not require a semi-colon, will return a value. i.e.
```
  set x 3
```
This returns the symbol x, unless you terminate it with a semicolon
```
  set x 3
```

Pattern Matching
--------------------------------------------------
Exploring ways for the pattern matcher to work.

One way do it is to keep an array of all the objects that have
been processed.  Each potential pattern that has been matched
can then indicate which "match type" it used to match each object.
The following table demonstrates this:

|Processed Object Types |   uint    |   utf8    |  bool  |
|-----------------------|-----------|-----------|--------|
|Pattern 0 Match Types  |  unsigned |  anything |  bool  |
|Pattern 1 Match Types  |  number   |  string   |  bool  |

In this example the best matched pattern should probably be
ambiguous because pattern 0 matches the first object better,
but pattern 1 matches the second object better.

For patterns that contain raw symbols, I think the best way to
handle those is to give them priority.  If a pattern matches
a raw node, then all other patterns are temporarily dropped (unless they
also matched a raw node at the same time).  If any of the patterns
that matched the raw node match their entire pattern, then they
will be the "best matched pattern".


ConstructString type
--------------------------------------------------
I think I should update the construct string type
to be non-nullable.  Instead of a string being
a pointer and length, I think I want it to actually
mean a real string.  So a string can't be null, it could
be empty, but null doesn't mean anything.


Optional pattern node
--------------------------------------------------
Say you have a construct like this:
```
defcon someConstruct(str optional string)
{
  //...
}
```

It matches a string, but it's an "optional" string.
I think the symbol table entry for str should indicate it is an "optional string".
However, as the code works with the symbol, information can be extracted about
the symbol, and that information can even update the type information in the
symbol table.

For example, say there is an "isPresent" construct that checks whether or not
an optional value is present.  If this construct returns true, then that means the
type in the symbol table can be updated to a regular string, instead of an
optional one.

Note: the 'isPresent' construct should probably be defined something like this:
```
defop . (obj optionalType, _ 'isPresent')
{
  // Note: optionalType is a type that matches any
  //       object that is optional.
  //
  // optionalType (parent type)
  //    |
  //    |-- optional number (child type)
  //    |
  //    |-- optional string (child type)
  //    |
  //    ...
  //
  // This construct will probably be implemented internally.
  // It returns true/false depending on whether the
  // object was matched.
  //
  //
  // If it returns true (the object was matched), it should update
  // the variables entry in the symbol table from "optional x" to "x".
}
```
> Note: this construct should also work on the 'else if' or 'else' i.e.
```
if(not str.isPresent) {
  // str is still an optional string
} else if (...) {
  // str is a regular string
} else {
  // str is a regular string
}
```

Note: defop means that the construct will be matched on the "right" side of the first pattern node.
Here's some examples:
```
. 0 isPresent         // will not match, '.' is on the "left" side
0 . isPresent         // will match, '.' is on the "right" side
0.isPresent           // also ok
"something".isPresent // also ok
```

Extensible Syntax
--------------------------------------------------
I could make the syntax extensible.
I could have some special construct that the parser is able to
identify, and it will indicate that a new syntax is about to begin:

setSyntax MyCustomSyntax

When the parser sees this, it will try to lookup the syntax in the symbol table.
If it isn't present, it will stop parsing and process whatever objects it has already
parsed, then it will try to parse the syntax again starting where it left off.


Pattern Consumers:
--------------------------------------------------
Consume objects if they match the pattern.


The '+' construct
  number '+' number
  pointer '+' number
  pointer '+' pointer

The '/' construct
  number '/' number


8 + 4 / 2
8 / 4 + 2

The '++' construct
  number '++'
  pointer '++'




The 'message' construct
  'message' anything* ';'





Pattern Branches
-------------------------------------
```
#### let construt
symbol value break?

symbol value break
symbol value

defcon let (newSymbol symbol, value, optional break)
{
    // code to add symbol

}

#### struct construct

defcon struct block
{
  // ...
}

#### try construct

Expression: block ('catch' (symbol type?)? block)* ('finally' block)?

struct CatchInfo {
  errorSymbol symbol;
  errorType type;
  handler block;
}

defcon try (tryBlock block, catchBlocks CatchInfo list itemPrefix="catch", finallyBlock block prefix="finally")
{
  // ...
}

defcon <name> (<consumer>)

<consumer> = <name> [<type>] [options]

consumer option: itemPrefix=<string>
    The presence of <string> means another item is about to appear
consumer option: prefix=<string>
    The argument is only present if prefixed by <string>




// Pattern
  Type (some examples):
    anything named? nullable? type symbol bool pointer
    number integer signed int byte unsigned uint ubyte
    uni construct block list array string ascii unicode
    utf8
  CountType:
    one (must appear once)
    optional (may or may not appear)
      prefix (presence may be dependent on a prefix keyword)
    list
      prefix (The list as a whole is present based on a keyword)
      itemPrefix (each item has the given prefix)



try {
  // some code
} catch e MyCoolException {
  // the catch code
} catch e AnotherException {
  // more catch code
} finally {
  // the finally code
}

```


Pattern State Machines
================================================================================
Given that you have every pattern for a construct, construct a state machine
that will consume that construct.

defcon let (name symbol, value object)

let catchPattern pattern(varName symbol, catchType type optional, catchBlock block);

defcon try (tryBlock block, catchBlocks catchPattern list itemPrefix='catch', finallyBlock block option prefix='finally')

### How to create a state machine from a pattern

nodes and transitions

start with a node:

pattern (s string)




